# -*- coding: utf-8 -*-
"""NAS Image Learning GAP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XR_L6w6tQr9neqBkUNTGfAzYNsZhw4jZ
"""

# https://modelzoo.co/
import zipfile 
f = zipfile.ZipFile("drive/My Drive/Colab Notebooks/cat/train.zip")
f.extractall ()

import pandas as pd
import glob
dogs = glob.glob ("train/dog.*")
cats = glob.glob ("train/cat.*")

df = pd.DataFrame ({
    "path": dogs + cats, 
    "target": [0] * len(dogs) + [1] * len(cats)
    })
df

import random
from tensorflow.keras.preprocessing.image import load_img
idx = random.randint (0, 24999)
load_img(df["path"][idx], target_size=(224,224))

import numpy as np
from sklearn.model_selection import train_test_split
x, y = np.array (df["path"]), np.array(df["target"])
x_train, x_test, y_train, y_test = train_test_split (x,y,test_size = 0.1)
print (x_train.shape)
print (x_test.shape)
print (y_train.shape)
print (y_test.shape)

from tensorflow.keras.applications import NASNetLarge
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten, GlobalAveragePooling2D
from tensorflow.keras.layers import BatchNormalization # 要銜接不同 model 中間輸出輸入要 Normalization
from tensorflow.keras.models import Model
# 原來
base_model = NASNetLarge(
    input_shape=(331,331,3),
    include_top=False,
    weights="imagenet",
    input_tensor=None,
    pooling=None,
    #classes="2",
)


for layer in base_model.layers:
  layer.trainable = False

x=base_model.output
x=GlobalAveragePooling2D ()(x)
x=Dense (128, activation = "relu")(x)
predictions = Dense (2, activation = "softmax")(x)
model= Model(base_model.input, predictions)
model.summary ()



from tensorflow.keras.losses import SparseCategoricalCrossentropy
from tensorflow.keras.optimizers import Adam
model.compile(loss=SparseCategoricalCrossentropy(),
       optimizer=Adam(),
       metrics=["accuracy"])

#https://keras-cn.readthedocs.io/en/latest/models/model/
#train_on_batch
#test_on_batch

import numpy as np
from tensorflow.keras.applications import nasnet

x = x_train

def getdata (x,y,batch = 100):
  idx = np.random.randint (0, x.shape[0], size = batch)
  orix, batch_x, batch_y = [], [], y [idx]
  for p in x[idx]:
    img = load_img (p, target_size =(224, 224))
    img_np = np.array (img)
    orix.append (img_np)
    img_pre = nasnet.preprocess_input (img_np) # transfer learning 用他的預處理方式
    batch_x.append (img_pre)
  return (np.array(orix), np.array (batch_x), np.array(batch_y))

testimg, testx, testy = getdata (x_test, y_test, 20)

for i in range (20):
  print ("-"*15, i, "-"*15)
  trainimg, trainx, trainy = getdata(x_train, y_train, 20)
  result = model.train_on_batch (trainx, trainy)
  print ("Train:", result)
  result = model.test_on_batch (testx, testy)
  print ("Validate:", result)
  print ("-"*15, i, "-"*15)

model.predict (trainx)

testimg, testx, testy = getdata (x_test, y_test, 1000)
model.evaluate(testx, testy)

testimg, testx, testy = getdata (x_test, y_test, 1000)
print (testy)
pre = model.predict (testx)
answer = []
for n in range (len(pre)):
  get_answer = pre[n]
  if get_answer[0] >= get_answer[1]:
    result = 0
  elif get_answer[0] < get_answer[1]:
    result = 1
  answer.append(result)

pre = np.array(answer)
print (pre)

# subplot(總高度, 總寬度, ith)
import numpy as np
import matplotlib.pyplot as plt

#pre = model.predict (testx)
#print (pre)
trans = ["Dog", "Cat"]
idx = np.nonzero(pre != testy)[0]
idx = idx[:200]
false_img = testimg[idx]
false_label = testy[idx]
false_pre = pre[idx]

plt.figure(figsize=(14, 4))
width = 10
height = len(false_img) // width + 1
for i in range(len(false_img)):
    plt.subplot(height, width, i+1)
    title = "[O]:{}\n[P]:{}".format(trans[false_label[i]], trans[false_pre[i]])
    plt.title(title)
    plt.axis("off")
    plt.imshow(false_img[i])



# pip install pillow
import PIL
import requests
url = "https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcSOE_6cCV1OCLhwBAC5eo8MWtUKl7ye0YMb9A&usqp=CAU"
h = {"user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36"}
response = requests.get(url, stream=True, verify=False, headers=h)
img = PIL.Image.open(response.raw).resize((224, 224))
img_np = np.array(img)
test = nasnet.preprocess_input(img_np.reshape(1, 224, 224, 3))
probs = model.predict(test)[0]
for i, p in enumerate(probs):
    print(trans[i], "的機率是:", round(p, 3))
  
ans = model.predict(test)[0]
if ans[0] >= ans[1]:
  ans=0
else:
  ans=1
print("應該是:", trans[ans])
plt.imshow(img_np)